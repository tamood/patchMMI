#!/bin/python
import xml.etree.ElementTree as ET
import json
import argparse

#recursive implementation of xml indentation
def indent(elem, indent_by, level=0):
    i = "\n" + level*indent_by
    if len(elem):
        elem.text=None
        elem.tail=None
        if not elem.text or not elem.text.strip():
            elem.text = i + indent_by
        if not elem.tail or not elem.tail.strip():
            elem.tail = i
        for elem in elem:
            indent(elem, indent_by, level+1)
        if not elem.tail or not elem.tail.strip():
            elem.tail = i
    else:
        if level and (not elem.tail or not elem.tail.strip()):
            elem.tail = i

# --i Input MMI file generated by XPM flow
# --d Input JSON file generated by chisel/firrtl
# --o Output MMI file for elf flow, containing busblocks and bitlanes geometry
p=argparse.ArgumentParser()
p.add_argument("--i")
p.add_argument("--d")
p.add_argument("--o")

args=p.parse_args()
input_file = args.i
output_file = args.o
dts_json = args.d

# Extract bootrom memory map from DTS
with open(dts_json) as json_file:
    data = json.load(json_file)
    rockchip_romsize=data['soc']['rom@10000']['reg'][0]['size']
    mem_addr_begin=data['soc']['rom@10000']['reg'][0]['base']
    mem_addr_end=mem_addr_begin+rockchip_romsize-1

# parse input MMI into xml tree, get tree root
tree = ET.parse(input_file)
root = tree.getroot()

# make a child node of root MEMInfo
proc = ET.SubElement(root, 'Processor')
proc.set('Endianness',"Little")
proc.set('InstPath',"rocketchip")   

# specify memory map 
addr = ET.SubElement(proc, 'AddressSpace')
addr.set('Name',root[0][0].attrib['Name'])
addr.set('Begin',str(mem_addr_begin))
addr.set('End',str(mem_addr_end))

# Read all BlockRAMS of XPMflow into brams list, get output bus width
layout = root.find(".//MemoryLayout")
datawidth=int(layout.attrib["CoreMemory_Width"]);
brams=layout.findall(".//BRAM")

# Assume homogeneous BRAM array, calculate bus w  
bw = brams[0].find("DataWidth_PortA")
w = int(bw.attrib["MSB"])-int(bw.attrib["LSB"])+1

# arrange bitlanes in an order, updatemem expects, this is crux of this patch
bitlanes=[]
if(w<8):
    for offset in range(0, datawidth, 8):
        for r in range(8,0,-w):
            msb, lsb = r - 1, r - w
            bitlanes.append((msb+offset, lsb+offset))
else:
    msb, lsb = w - 1, 0
    bitlanes = [(msb+offset, lsb+offset) for offset in range(0, datawidth, w)]

# Make a dictionary of bram info, keyed with their position in output MMI
bram_table={}
for bram in brams:
    addr_range=bram.find("AddressRange_PortA")
    data_width=bram.find("DataWidth_PortA")
    addr_begin=addr_range.attrib["Begin"];
    addr_end=addr_range.attrib["End"];
    bits_lsb=data_width.attrib["LSB"];
    bits_msb=data_width.attrib["MSB"];
    idx = bitlanes.index((int(bits_msb), int(bits_lsb)))
    idx = idx + int(addr_begin)
    bram_table[idx]=(addr_begin, addr_end, bits_lsb, bits_msb, bram.attrib['Placement'], bram.attrib["MemType"])

# done with old MemoryArray
root.remove(root.find("./MemoryArray"))

# get things in order
indices=list(dict.fromkeys(bram_table))
indices.sort()

# Populate XML in required order
busblocks={}
for i in indices:
    bram = bram_table[i]
    addr_begin=bram[0]
    addr_end=bram[1]
    bits_lsb=bram[2]
    bits_msb=bram[3]
    bram_place=bram[4]
    bram_type=bram[5]
    if(busblocks.get(addr_begin)==None):
        # make new block
        bb = ET.SubElement(addr, 'BusBlock')
        busblocks[addr_begin] = bb

    busblock = busblocks[addr_begin]
    bl = ET.SubElement(busblock, 'BitLane')
    bl.set('MemType',bram_type)
    bl.set('Placement',bram_place)

    dwidth=ET.SubElement(bl, 'DataWidth')
    dwidth.set('MSB',bits_msb)
    dwidth.set('LSB',bits_lsb)

    addrrr=ET.SubElement(bl, 'AddressRange')
    addrrr.set('Begin',addr_begin)
    addrrr.set('End',addr_end)

    parity=ET.SubElement(bl, 'Parity')
    parity.set('ON',"false")
    parity.set('NumBits',"0")

#

# to please updatemem
config=root.find("./Config")
drc=root.find("./DRC")

root.remove(config)
root.remove(drc)
root.append(config)
root.append(drc)

# beautify
indent(root, "\t")    

# we are done
with open(output_file, 'wb') as f:
    f.write(b'<?xml version="1.0" encoding="UTF-8"?>\n');
    tree.write(f, xml_declaration=False, encoding='utf-8')  